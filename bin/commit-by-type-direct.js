#!/usr/bin/env node

/**
 * Script to group and commit changes by type in DiffSense
 * Version with improved terminal interface
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { createInterface } from 'readline';
import path from 'path';

const execAsync = promisify(exec);

// Check if the --show-only option was passed
const showOnly = process.argv.includes('--show-only');

// Interface for user interaction
const rl = createInterface({
  input: process.stdin,
  output: process.stdout
});

/**
 * Ask the user with promise for response
 */
function question(query) {
  return new Promise(resolve => rl.question(query, resolve));
}

/**
 * Executa um comando git silenciosamente e retorna a sa√≠da
 */
async function runCommand(command, silent = true) {
  try {
    if (!silent) {
      console.log(`> ${command}`);
    }
    const { stdout, stderr } = await execAsync(command);
    if (stderr && !stderr.includes('warning:') && !silent) {
      console.error(`‚ö†Ô∏è ${stderr}`);
    }
    return stdout.trim();
  } catch (error) {
    if (!silent) {
      console.error(`‚ùå Erro: ${error.message}`);
    }
    return '';
  }
}

/**
 * Mostra uma barra de progresso no terminal
 */
function showProgress(message, percent) {
  const width = 30;
  const completed = Math.floor(width * (percent / 100));
  const remaining = width - completed;
  const bar = '‚ñà'.repeat(completed) + '‚ñë'.repeat(remaining);
  process.stdout.write(`\r${message} [${bar}] ${percent}%`);
  if (percent === 100) {
    process.stdout.write('\n');
  }
}

/**
 * Main function
 */
async function commitByType() {
  try {
    console.log('\nüîç DiffSense - Commit por Tipo\n');
    console.log('Analisando reposit√≥rio...');
    
    // Mostrar barra de progresso enquanto detecta arquivos
    showProgress('Looking for changes', 20);
    
    // Get modified files that are not staged (unstaged)
    const modifiedFiles = await runCommand('git ls-files -m');
    
    showProgress('Looking for changes', 40);
    
    // Get untracked files
    const untrackedFiles = await runCommand('git ls-files --others --exclude-standard');
    
    showProgress('Looking for changes', 60);
    
    // Obter arquivos preparados (staged)
    const stagedFiles = await runCommand('git diff --cached --name-only');
    
    showProgress('Procurando altera√ß√µes', 100);
    
    // Combinar todas as altera√ß√µes (sem duplicatas)
    const allChanges = [...new Set([...modifiedFiles.split('\n'), ...untrackedFiles.split('\n'), ...stagedFiles.split('\n')])];
    const files = allChanges.filter(Boolean);
    
    if (files.length === 0) {
      console.log('\n‚ú® Reposit√≥rio limpo! N√£o h√° altera√ß√µes para commitar.');
      rl.close();
      return;
    }
    
    console.log(`\n‚úÖ Encontradas ${files.length} altera√ß√µes no reposit√≥rio.`);
    
    // Classificar arquivos por tipo
    const fileTypes = {
      'feat': [],
      'fix': [],
      'docs': [],
      'refactor': [],
      'test': [],
      'chore': [],
      // Adicionar categorias para breaking changes
      'feat!': [],
      'fix!': [],
      'refactor!': [],
      'docs!': []
    };
    let processedFiles = 0;
    
    // Iniciar barra de progresso para classifica√ß√£o
    showProgress('Classificando altera√ß√µes', 0);
    
    for (const filePath of files) {
      const ext = path.extname(filePath).toLowerCase();
      const fileName = path.basename(filePath).toLowerCase();
      
      // Analisar o caminho e determinar o tipo de altera√ß√£o
      // Para uma biblioteca npm, precisamos classificar com cuidado o que impacta os usu√°rios
      
      // Por padr√£o, come√ßamos com chore (n√£o afeta versionamento)
      let type = 'chore';
      
      // 1. TESTES - importantes, mas n√£o impactam a API p√∫blica
      if (filePath.includes('/tests/') || 
          filePath.includes('\\tests\\') ||
          filePath.includes('/test/') || 
          filePath.includes('\\test\\') ||
          filePath.includes('/__tests__/') || 
          filePath.includes('\\_tests__\\') ||
          fileName.endsWith('.test.js') ||
          fileName.endsWith('.test.ts') ||
          fileName.endsWith('.spec.js') ||
          fileName.endsWith('.spec.ts')) {
        type = 'test';
      }
      
      // 2. DOCUMENTA√á√ÉO P√öBLICA - afeta os usu√°rios finais
      else if (fileName.toLowerCase() === 'readme.md' || 
               fileName.toLowerCase() === 'license' || 
               (ext === '.md' && (
                 fileName.toLowerCase().includes('changelog') || 
                 filePath.toLowerCase().includes('/docs/') || 
                 filePath.toLowerCase().includes('\\docs\\')
               ))) {
        
        // Verificar se √© documenta√ß√£o com breaking changes
        if (fileName.toLowerCase().includes('breaking') || 
            fileName.toLowerCase().includes('migration') || 
            fileName.toLowerCase().includes('upgrade') || 
            fileName.toLowerCase().includes('v2') || 
            fileName.toLowerCase().includes('v3')) {
          type = 'docs!';
        } else {
          type = 'docs';
        }
      }
      
      // 3. CORRE√á√ïES ESPEC√çFICAS CONHECIDAS
      else if (filePath.includes('change-detector.ts') || 
               filePath.includes('commit-by-type-direct.js')) {
        // Verificar se s√£o corre√ß√µes que podem ser breaking changes
        if (filePath.includes('types') || filePath.includes('api') || 
            filePath.includes('interface') || filePath.includes('export')) {
          type = 'fix!'; // Potencialmente um breaking change
        } else {
          type = 'fix';
        }
      }
      
      // 4. C√ìDIGO-FONTE DA API P√öBLICA
      else if (['.js', '.ts', '.jsx', '.tsx'].includes(ext)) {
        // Verificar se √© c√≥digo fonte da API p√∫blica (exportado pelo pacote)
        if (filePath.startsWith('src/types/') || 
            filePath.startsWith('src\\types\\') ||
            filePath.startsWith('src/core/') ||
            filePath.startsWith('src\\core\\') ||
            filePath.startsWith('src/api/') ||
            filePath.startsWith('src\\api\\') ||
            filePath === 'src/index.ts' ||
            filePath === 'src\\index.ts' ||
            filePath === 'src/index.js' ||
            filePath === 'src\\index.js') {
          
          // Verificar se √© um breaking change
          let isBreaking = false;
          
          // Heur√≠sticas para detectar breaking changes
          // Verificar especificamente o arquivo de tipos para detectar breaking changes
          if (filePath === 'src/types/index.ts' || filePath === 'src\\types\\index.ts') {
            // Este √© um arquivo cr√≠tico para a API p√∫blica, ent√£o verificamos com cuidado
            // Neste caso espec√≠fico, sabemos que modificamos o CommitType para incluir 'chore'
            // o que pode ser considerado um breaking change se algu√©m dependia dessa defini√ß√£o
            type = 'feat!'; // Marcar como breaking change
            isBreaking = true;
          }
          // Outras heur√≠sticas gerais para detectar breaking changes
          else if (filePath.includes('/breaking/') || 
              filePath.includes('\\breaking\\') || 
              fileName.includes('break') || 
              fileName.includes('migration')) {
            isBreaking = true;
            
            // Adicionar √† categoria correspondente com o marcador '!'
            if (fileName.includes('fix') || 
                filePath.includes('/fixes/') || 
                filePath.includes('\\fixes\\')) {
              type = 'fix!';
            } else {
              type = 'feat!';
            }
          }
          // Se n√£o for breaking change
          else {
            // Arquivos de defini√ß√£o de tipo s√£o importantes para usu√°rios TypeScript
            if (ext === '.ts' && filePath.includes('/types/')) {
              type = 'feat';
            }
            // Detectar se √© corre√ß√£o ou feature
            else if (fileName.includes('fix') || 
                    filePath.includes('/fixes/') || 
                    filePath.includes('\\fixes\\')) {
              type = 'fix';
            } 
            else {
              type = 'feat';
            }
          }
        }
      }
      
      if (!fileTypes[type]) {
        fileTypes[type] = [];
      }
      fileTypes[type].push(filePath);
      
      // Atualizar barra de progresso
      processedFiles++;
      showProgress('Classificando altera√ß√µes', Math.floor((processedFiles / files.length) * 100));
    }
    
    // Resumo conciso das altera√ß√µes
    console.log('\nüìä Altera√ß√µes classificadas por tipo:');
    const types = Object.keys(fileTypes).filter(type => fileTypes[type].length > 0);
    
    // Separar tipos normais e breaking changes
    const regularTypes = types.filter(type => !type.includes('!'));
    const breakingTypes = types.filter(type => type.includes('!'));
    
    // Mostrar estat√≠sticas de tipos normais
    const regularStats = regularTypes.map(type => `${type}: ${fileTypes[type].length}`).join(', ');
    console.log(`   ${regularStats}`);
    
    // Destacar breaking changes, se houver
    if (breakingTypes.length > 0) {
      const breakingStats = breakingTypes.map(type => `${type}: ${fileTypes[type].length}`).join(', ');
      console.log(`\n‚ö†Ô∏è  BREAKING CHANGES detectadas:`);
      console.log(`   ${breakingStats}`);
    }
    
    // Mostrar detalhes apenas se houver poucos tipos ou se estiver no modo --show-only
    if (types.length <= 3 || showOnly) {
      types.forEach(type => {
        const fileCount = fileTypes[type].length;
        if (fileCount <= 3 || showOnly) {
          console.log(`   ‚Ä¢ ${type} (${fileCount}): ${fileTypes[type].map(f => path.basename(f)).join(', ')}`);
        } else {
          console.log(`   ‚Ä¢ ${type} (${fileCount}): ${fileTypes[type].slice(0, 2).map(f => path.basename(f)).join(', ')}... e outros ${fileCount - 2}`);
        }
      });
    }
    
    // Se estiver no modo --show-only, apenas mostrar os dados e finalizar
    if (showOnly) {
      console.log('\nüìã Modo de visualiza√ß√£o apenas. Nenhum commit ser√° realizado.');
      rl.close();
      return;
    }
    
    // Verificar se o usu√°rio deseja fazer os commits
    const confirmCommit = await question('\nDeseja fazer o commit das altera√ß√µes? (S/n): ');
    
    if (!confirmCommit || confirmCommit.toLowerCase() === 's') {
      console.log('\nüöÄ Iniciando processo de commits...');
      
      // Preparar mensagens de commit para cada tipo
      const commitMessages = {};
      for (const type of types) {
        // Tratar adequadamente tipos de breaking changes
        if (type.endsWith('!')) {
          // Extrair o tipo base (sem o !)
          const baseType = type.slice(0, -1);
          const suggestedMessage = `${baseType}!: BREAKING CHANGE - altera√ß√µes incompat√≠veis em ${baseType}`;
          commitMessages[type] = suggestedMessage;
        } else {
          const suggestedMessage = `${type}: altera√ß√µes em arquivos de ${type}`;
          commitMessages[type] = suggestedMessage;
        }
      }
      
      // Realizar commits por tipo, um ap√≥s o outro
      let commitCount = 0;
      
      for (const type of types) {
        const files = fileTypes[type] || [];
        
        if (files.length === 0) continue;
        
        const message = commitMessages[type];
        const totalCommits = types.filter(t => fileTypes[t].length > 0).length;
        
        // Mostrar progresso
        commitCount++;
        showProgress(`Processando commits (${commitCount}/${totalCommits})`, 
                     Math.floor((commitCount / totalCommits) * 100));
        
        console.log(`\n\nüì¶ Commit ${commitCount}/${totalCommits}: ${type.toUpperCase()} (${files.length} arquivos)`);
        console.log(`   Mensagem: "${message}"`);
        
        try {
          // Limpar staging area
          await runCommand('git reset', true);
          
          // Adicionar arquivos e fazer o commit em um √∫nico passo
          let addedFiles = 0;
          for (const file of files) {
            try {
              await runCommand(`git add "${file}"`, true);
              addedFiles++;
            } catch (e) {
              // Ignorar erros de arquivos individuais
            }
          }
          
          if (addedFiles === 0) {
            console.log('   ‚ö†Ô∏è Nenhum arquivo adicionado, pulando commit.');
            continue;
          }
          
          // Fazer o commit
          await runCommand(`git commit -m "${message}"`, false);
          console.log(`   ‚úÖ Commit realizado com sucesso!`);
        } catch (error) {
          console.log(`   ‚ùå Erro ao realizar commit: ${error.message}`);
        }
      }
      
      console.log('\n‚ú® Processo de commits conclu√≠do com sucesso!');
    } else {
      console.log('\n‚ùå Opera√ß√£o cancelada pelo usu√°rio.');
    }
    console.log('\nüëã Obrigado por usar o DiffSense Commit por Tipo!');
    rl.close();
  } catch (error) {
    console.error('\n‚ùå Erro durante o processo:', error);
    rl.close();
  }
}

// Exibir cabe√ßalho
console.log('\n‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ');
console.log('‚îÇ       DiffSense - Commit por Tipo      ‚îÇ');
console.log('‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ');

// Executar a fun√ß√£o principal
commitByType();
